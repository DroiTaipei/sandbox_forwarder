// Code generated by protoc-gen-go.
// source: memento.proto
// DO NOT EDIT!

/*
Package protobuf is a generated protocol buffer package.

It is generated from these files:
	memento.proto

It has these top-level messages:
	RequestCache
	RequestKey
	RequestCollection
	RequestQuery
	Data
	Result
	SetResult
	AllResult
	CodeResult
	CountResult
*/
package protobuf

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type RequestCache struct {
	// key limited less than 1024 bytes
	Key string `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty"`
	// BSON contains field : 1. Value limited less than 1MB (this may be changed in the future)
	// Use BSON bytes to help golang preserving type
	BSON       []byte            `protobuf:"bytes,2,opt,name=BSON,proto3" json:"BSON,omitempty"`
	DBN        string            `protobuf:"bytes,3,opt,name=DBN" json:"DBN,omitempty"`
	Collection string            `protobuf:"bytes,4,opt,name=Collection" json:"Collection,omitempty"`
	TTLSec     int32             `protobuf:"varint,5,opt,name=TTLSec" json:"TTLSec,omitempty"`
	Headers    map[string]string `protobuf:"bytes,6,rep,name=Headers" json:"Headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RequestCache) Reset()                    { *m = RequestCache{} }
func (m *RequestCache) String() string            { return proto.CompactTextString(m) }
func (*RequestCache) ProtoMessage()               {}
func (*RequestCache) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *RequestCache) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *RequestCache) GetBSON() []byte {
	if m != nil {
		return m.BSON
	}
	return nil
}

func (m *RequestCache) GetDBN() string {
	if m != nil {
		return m.DBN
	}
	return ""
}

func (m *RequestCache) GetCollection() string {
	if m != nil {
		return m.Collection
	}
	return ""
}

func (m *RequestCache) GetTTLSec() int32 {
	if m != nil {
		return m.TTLSec
	}
	return 0
}

func (m *RequestCache) GetHeaders() map[string]string {
	if m != nil {
		return m.Headers
	}
	return nil
}

type RequestKey struct {
	Key        string            `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty"`
	DBN        string            `protobuf:"bytes,2,opt,name=DBN" json:"DBN,omitempty"`
	Collection string            `protobuf:"bytes,3,opt,name=Collection" json:"Collection,omitempty"`
	Headers    map[string]string `protobuf:"bytes,4,rep,name=Headers" json:"Headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RequestKey) Reset()                    { *m = RequestKey{} }
func (m *RequestKey) String() string            { return proto.CompactTextString(m) }
func (*RequestKey) ProtoMessage()               {}
func (*RequestKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *RequestKey) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *RequestKey) GetDBN() string {
	if m != nil {
		return m.DBN
	}
	return ""
}

func (m *RequestKey) GetCollection() string {
	if m != nil {
		return m.Collection
	}
	return ""
}

func (m *RequestKey) GetHeaders() map[string]string {
	if m != nil {
		return m.Headers
	}
	return nil
}

type RequestCollection struct {
	DBN        string            `protobuf:"bytes,1,opt,name=DBN" json:"DBN,omitempty"`
	Collection string            `protobuf:"bytes,2,opt,name=Collection" json:"Collection,omitempty"`
	Headers    map[string]string `protobuf:"bytes,3,rep,name=Headers" json:"Headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RequestCollection) Reset()                    { *m = RequestCollection{} }
func (m *RequestCollection) String() string            { return proto.CompactTextString(m) }
func (*RequestCollection) ProtoMessage()               {}
func (*RequestCollection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *RequestCollection) GetDBN() string {
	if m != nil {
		return m.DBN
	}
	return ""
}

func (m *RequestCollection) GetCollection() string {
	if m != nil {
		return m.Collection
	}
	return ""
}

func (m *RequestCollection) GetHeaders() map[string]string {
	if m != nil {
		return m.Headers
	}
	return nil
}

type RequestQuery struct {
	DBN        string            `protobuf:"bytes,1,opt,name=DBN" json:"DBN,omitempty"`
	Collection string            `protobuf:"bytes,2,opt,name=Collection" json:"Collection,omitempty"`
	BSONQuery  []byte            `protobuf:"bytes,3,opt,name=BSONQuery,proto3" json:"BSONQuery,omitempty"`
	Headers    map[string]string `protobuf:"bytes,4,rep,name=Headers" json:"Headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RequestQuery) Reset()                    { *m = RequestQuery{} }
func (m *RequestQuery) String() string            { return proto.CompactTextString(m) }
func (*RequestQuery) ProtoMessage()               {}
func (*RequestQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *RequestQuery) GetDBN() string {
	if m != nil {
		return m.DBN
	}
	return ""
}

func (m *RequestQuery) GetCollection() string {
	if m != nil {
		return m.Collection
	}
	return ""
}

func (m *RequestQuery) GetBSONQuery() []byte {
	if m != nil {
		return m.BSONQuery
	}
	return nil
}

func (m *RequestQuery) GetHeaders() map[string]string {
	if m != nil {
		return m.Headers
	}
	return nil
}

type Data struct {
	BSON      []byte `protobuf:"bytes,1,opt,name=BSON,proto3" json:"BSON,omitempty"`
	CreatedAt int64  `protobuf:"varint,2,opt,name=CreatedAt" json:"CreatedAt,omitempty"`
	ExpiredAt int64  `protobuf:"varint,3,opt,name=ExpiredAt" json:"ExpiredAt,omitempty"`
	Key       string `protobuf:"bytes,4,opt,name=Key" json:"Key,omitempty"`
}

func (m *Data) Reset()                    { *m = Data{} }
func (m *Data) String() string            { return proto.CompactTextString(m) }
func (*Data) ProtoMessage()               {}
func (*Data) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Data) GetBSON() []byte {
	if m != nil {
		return m.BSON
	}
	return nil
}

func (m *Data) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Data) GetExpiredAt() int64 {
	if m != nil {
		return m.ExpiredAt
	}
	return 0
}

func (m *Data) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type Result struct {
	Code  int32  `protobuf:"varint,1,opt,name=Code" json:"Code,omitempty"`
	Resp  *Data  `protobuf:"bytes,2,opt,name=Resp" json:"Resp,omitempty"`
	Error string `protobuf:"bytes,3,opt,name=Error" json:"Error,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Result) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Result) GetResp() *Data {
	if m != nil {
		return m.Resp
	}
	return nil
}

func (m *Result) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type SetResult struct {
	Code      int32  `protobuf:"varint,1,opt,name=Code" json:"Code,omitempty"`
	ExpiredAt int64  `protobuf:"varint,2,opt,name=ExpiredAt" json:"ExpiredAt,omitempty"`
	Error     string `protobuf:"bytes,3,opt,name=Error" json:"Error,omitempty"`
}

func (m *SetResult) Reset()                    { *m = SetResult{} }
func (m *SetResult) String() string            { return proto.CompactTextString(m) }
func (*SetResult) ProtoMessage()               {}
func (*SetResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *SetResult) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SetResult) GetExpiredAt() int64 {
	if m != nil {
		return m.ExpiredAt
	}
	return 0
}

func (m *SetResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type AllResult struct {
	Code  int32   `protobuf:"varint,1,opt,name=Code" json:"Code,omitempty"`
	Resp  []*Data `protobuf:"bytes,2,rep,name=Resp" json:"Resp,omitempty"`
	Error string  `protobuf:"bytes,3,opt,name=Error" json:"Error,omitempty"`
}

func (m *AllResult) Reset()                    { *m = AllResult{} }
func (m *AllResult) String() string            { return proto.CompactTextString(m) }
func (*AllResult) ProtoMessage()               {}
func (*AllResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *AllResult) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *AllResult) GetResp() []*Data {
	if m != nil {
		return m.Resp
	}
	return nil
}

func (m *AllResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type CodeResult struct {
	Code  int32  `protobuf:"varint,1,opt,name=Code" json:"Code,omitempty"`
	Error string `protobuf:"bytes,2,opt,name=Error" json:"Error,omitempty"`
}

func (m *CodeResult) Reset()                    { *m = CodeResult{} }
func (m *CodeResult) String() string            { return proto.CompactTextString(m) }
func (*CodeResult) ProtoMessage()               {}
func (*CodeResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CodeResult) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CodeResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type CountResult struct {
	Code  int32  `protobuf:"varint,1,opt,name=Code" json:"Code,omitempty"`
	Count int32  `protobuf:"varint,2,opt,name=Count" json:"Count,omitempty"`
	Error string `protobuf:"bytes,3,opt,name=Error" json:"Error,omitempty"`
}

func (m *CountResult) Reset()                    { *m = CountResult{} }
func (m *CountResult) String() string            { return proto.CompactTextString(m) }
func (*CountResult) ProtoMessage()               {}
func (*CountResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *CountResult) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CountResult) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *CountResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func init() {
	proto.RegisterType((*RequestCache)(nil), "protobuf.RequestCache")
	proto.RegisterType((*RequestKey)(nil), "protobuf.RequestKey")
	proto.RegisterType((*RequestCollection)(nil), "protobuf.RequestCollection")
	proto.RegisterType((*RequestQuery)(nil), "protobuf.RequestQuery")
	proto.RegisterType((*Data)(nil), "protobuf.Data")
	proto.RegisterType((*Result)(nil), "protobuf.Result")
	proto.RegisterType((*SetResult)(nil), "protobuf.SetResult")
	proto.RegisterType((*AllResult)(nil), "protobuf.AllResult")
	proto.RegisterType((*CodeResult)(nil), "protobuf.CodeResult")
	proto.RegisterType((*CountResult)(nil), "protobuf.CountResult")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Memento service

type MementoClient interface {
	Set(ctx context.Context, in *RequestCache, opts ...grpc.CallOption) (*SetResult, error)
	Get(ctx context.Context, in *RequestKey, opts ...grpc.CallOption) (*Result, error)
	Delete(ctx context.Context, in *RequestKey, opts ...grpc.CallOption) (*CodeResult, error)
	Query(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*AllResult, error)
	Flush(ctx context.Context, in *RequestCollection, opts ...grpc.CallOption) (*CodeResult, error)
	Count(ctx context.Context, in *RequestCollection, opts ...grpc.CallOption) (*CountResult, error)
	DropCollection(ctx context.Context, in *RequestCollection, opts ...grpc.CallOption) (*CodeResult, error)
}

type mementoClient struct {
	cc *grpc.ClientConn
}

func NewMementoClient(cc *grpc.ClientConn) MementoClient {
	return &mementoClient{cc}
}

func (c *mementoClient) Set(ctx context.Context, in *RequestCache, opts ...grpc.CallOption) (*SetResult, error) {
	out := new(SetResult)
	err := grpc.Invoke(ctx, "/protobuf.Memento/Set", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mementoClient) Get(ctx context.Context, in *RequestKey, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/protobuf.Memento/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mementoClient) Delete(ctx context.Context, in *RequestKey, opts ...grpc.CallOption) (*CodeResult, error) {
	out := new(CodeResult)
	err := grpc.Invoke(ctx, "/protobuf.Memento/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mementoClient) Query(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*AllResult, error) {
	out := new(AllResult)
	err := grpc.Invoke(ctx, "/protobuf.Memento/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mementoClient) Flush(ctx context.Context, in *RequestCollection, opts ...grpc.CallOption) (*CodeResult, error) {
	out := new(CodeResult)
	err := grpc.Invoke(ctx, "/protobuf.Memento/Flush", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mementoClient) Count(ctx context.Context, in *RequestCollection, opts ...grpc.CallOption) (*CountResult, error) {
	out := new(CountResult)
	err := grpc.Invoke(ctx, "/protobuf.Memento/Count", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mementoClient) DropCollection(ctx context.Context, in *RequestCollection, opts ...grpc.CallOption) (*CodeResult, error) {
	out := new(CodeResult)
	err := grpc.Invoke(ctx, "/protobuf.Memento/DropCollection", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Memento service

type MementoServer interface {
	Set(context.Context, *RequestCache) (*SetResult, error)
	Get(context.Context, *RequestKey) (*Result, error)
	Delete(context.Context, *RequestKey) (*CodeResult, error)
	Query(context.Context, *RequestQuery) (*AllResult, error)
	Flush(context.Context, *RequestCollection) (*CodeResult, error)
	Count(context.Context, *RequestCollection) (*CountResult, error)
	DropCollection(context.Context, *RequestCollection) (*CodeResult, error)
}

func RegisterMementoServer(s *grpc.Server, srv MementoServer) {
	s.RegisterService(&_Memento_serviceDesc, srv)
}

func _Memento_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestCache)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MementoServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.Memento/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MementoServer).Set(ctx, req.(*RequestCache))
	}
	return interceptor(ctx, in, info, handler)
}

func _Memento_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MementoServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.Memento/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MementoServer).Get(ctx, req.(*RequestKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Memento_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MementoServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.Memento/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MementoServer).Delete(ctx, req.(*RequestKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Memento_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MementoServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.Memento/Query",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MementoServer).Query(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Memento_Flush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MementoServer).Flush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.Memento/Flush",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MementoServer).Flush(ctx, req.(*RequestCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _Memento_Count_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MementoServer).Count(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.Memento/Count",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MementoServer).Count(ctx, req.(*RequestCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _Memento_DropCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MementoServer).DropCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.Memento/DropCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MementoServer).DropCollection(ctx, req.(*RequestCollection))
	}
	return interceptor(ctx, in, info, handler)
}

var _Memento_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protobuf.Memento",
	HandlerType: (*MementoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Set",
			Handler:    _Memento_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Memento_Get_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Memento_Delete_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _Memento_Query_Handler,
		},
		{
			MethodName: "Flush",
			Handler:    _Memento_Flush_Handler,
		},
		{
			MethodName: "Count",
			Handler:    _Memento_Count_Handler,
		},
		{
			MethodName: "DropCollection",
			Handler:    _Memento_DropCollection_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "memento.proto",
}

func init() { proto.RegisterFile("memento.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 580 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x94, 0xdf, 0x6e, 0xd3, 0x30,
	0x14, 0xc6, 0x9b, 0x38, 0xe9, 0xc8, 0x69, 0x99, 0x86, 0x19, 0x55, 0x54, 0x26, 0x54, 0xc2, 0x4d,
	0xaf, 0x8a, 0x54, 0xd0, 0x84, 0x06, 0xbb, 0x58, 0xff, 0x00, 0xd2, 0x58, 0x11, 0xee, 0x84, 0xc4,
	0x65, 0xd6, 0x1e, 0xd4, 0x69, 0x59, 0x53, 0x5c, 0x07, 0xd1, 0xf7, 0xe1, 0x55, 0xb8, 0xe0, 0x11,
	0x78, 0x14, 0xee, 0x90, 0x9d, 0x34, 0x36, 0xb4, 0x8d, 0xd8, 0xa4, 0x5e, 0x25, 0x3e, 0xe7, 0x7c,
	0xf6, 0xf7, 0xb3, 0x8f, 0x0d, 0x77, 0xaf, 0xf1, 0x1a, 0xa7, 0x22, 0x6e, 0xcd, 0x78, 0x2c, 0x62,
	0x7a, 0x47, 0x7d, 0x2e, 0x92, 0xcf, 0xc1, 0x6f, 0x0b, 0xaa, 0x0c, 0xbf, 0x24, 0x38, 0x17, 0xdd,
	0x70, 0x34, 0x41, 0xba, 0x07, 0xe4, 0x14, 0x17, 0xbe, 0xd5, 0xb0, 0x9a, 0x1e, 0x93, 0xbf, 0x94,
	0x82, 0xd3, 0x19, 0xbe, 0x1f, 0xf8, 0x76, 0xc3, 0x6a, 0x56, 0x99, 0xfa, 0x97, 0x55, 0xbd, 0xce,
	0xc0, 0x27, 0x69, 0x55, 0xaf, 0x33, 0xa0, 0x8f, 0x00, 0xba, 0x71, 0x14, 0xe1, 0x48, 0x5c, 0xc6,
	0x53, 0xdf, 0x51, 0x09, 0x23, 0x42, 0x6b, 0x50, 0x3e, 0x3f, 0x7f, 0x37, 0xc4, 0x91, 0xef, 0x36,
	0xac, 0xa6, 0xcb, 0xb2, 0x11, 0x3d, 0x86, 0x9d, 0xb7, 0x18, 0x8e, 0x91, 0xcf, 0xfd, 0x72, 0x83,
	0x34, 0x2b, 0xed, 0x27, 0xad, 0xa5, 0xb9, 0x96, 0x69, 0xac, 0x95, 0x55, 0xf5, 0xa7, 0x82, 0x2f,
	0xd8, 0x52, 0x53, 0x3f, 0x82, 0xaa, 0x99, 0x90, 0xc6, 0xae, 0xb4, 0xfd, 0x2b, 0x5c, 0xd0, 0x7d,
	0x70, 0xbf, 0x86, 0x51, 0x82, 0xca, 0xbf, 0xc7, 0xd2, 0xc1, 0x91, 0xfd, 0xc2, 0x0a, 0x7e, 0x5a,
	0x00, 0xd9, 0x12, 0x92, 0x73, 0x95, 0x3c, 0xa3, 0xb4, 0x37, 0x51, 0x92, 0x15, 0xca, 0x97, 0x9a,
	0xc6, 0x51, 0x34, 0x8f, 0x57, 0x68, 0x4e, 0x71, 0xb1, 0x05, 0x96, 0x1f, 0x16, 0xdc, 0x5b, 0x6e,
	0x97, 0xb6, 0x93, 0x01, 0x58, 0x9b, 0x00, 0xec, 0x15, 0x80, 0x8e, 0x06, 0x20, 0x0a, 0xa0, 0xb9,
	0x7a, 0x1c, 0x79, 0xf5, 0x16, 0x38, 0x7e, 0xe9, 0x7e, 0xfc, 0x90, 0x20, 0x5f, 0xdc, 0x02, 0xe1,
	0x00, 0x3c, 0xd9, 0xa3, 0x4a, 0xae, 0x8e, 0xa8, 0xca, 0x74, 0xc0, 0xec, 0x37, 0x67, 0x43, 0xbf,
	0xa9, 0xc2, 0x2d, 0xb0, 0x4d, 0xc0, 0xe9, 0x85, 0x22, 0xcc, 0x2f, 0x94, 0x65, 0x5c, 0xa8, 0x03,
	0xf0, 0xba, 0x1c, 0x43, 0x81, 0xe3, 0x13, 0xa1, 0x94, 0x84, 0xe9, 0x80, 0xcc, 0xf6, 0xbf, 0xcd,
	0x2e, 0xb9, 0xca, 0x92, 0x34, 0x9b, 0x07, 0x96, 0x8d, 0xeb, 0xe4, 0x8d, 0x1b, 0x7c, 0x84, 0x32,
	0xc3, 0x79, 0x12, 0x09, 0xb9, 0x56, 0x37, 0x1e, 0xa3, 0x5a, 0xcb, 0x65, 0xea, 0x9f, 0x06, 0xe0,
	0x30, 0x9c, 0xcf, 0xd4, 0x32, 0x95, 0xf6, 0xae, 0xe6, 0x97, 0xee, 0x98, 0xca, 0x49, 0x8a, 0x3e,
	0xe7, 0x31, 0xcf, 0x7a, 0x3c, 0x1d, 0x04, 0x43, 0xf0, 0x86, 0x28, 0x0a, 0xa6, 0xfe, 0xcb, 0xa8,
	0xfd, 0xaf, 0xd1, 0xf5, 0x93, 0x7e, 0x02, 0xef, 0x24, 0x8a, 0xfe, 0xcb, 0x2f, 0xb9, 0xa1, 0xdf,
	0x43, 0xd9, 0x2a, 0x63, 0x2c, 0x98, 0x3b, 0xd7, 0xd9, 0xa6, 0xee, 0x0c, 0x2a, 0xdd, 0x38, 0x99,
	0x8a, 0x62, 0xa1, 0x2a, 0x51, 0x42, 0x97, 0xa5, 0x83, 0xf5, 0x36, 0xda, 0xdf, 0x09, 0xec, 0x9c,
	0xa5, 0x0f, 0x30, 0x7d, 0x0e, 0x64, 0x88, 0x82, 0xd6, 0xd6, 0xbf, 0x72, 0xf5, 0xfb, 0x3a, 0x9e,
	0xef, 0x74, 0x50, 0xa2, 0x4f, 0x81, 0xbc, 0x41, 0x41, 0xf7, 0xd7, 0xbd, 0x26, 0xf5, 0x3d, 0x33,
	0x9a, 0x09, 0x0e, 0xa1, 0xdc, 0xc3, 0x08, 0x05, 0x6e, 0xd0, 0x18, 0x51, 0xbd, 0x43, 0x4a, 0xe7,
	0xa6, 0xf7, 0xa4, 0xb6, 0xfe, 0x5a, 0x98, 0x06, 0xf3, 0x53, 0x0b, 0x4a, 0xf4, 0x15, 0xb8, 0xaf,
	0xa3, 0x64, 0x3e, 0xa1, 0x0f, 0x0b, 0xde, 0x8b, 0x8d, 0xab, 0x1e, 0x67, 0x9b, 0x59, 0xac, 0x7e,
	0x60, 0xaa, 0xf3, 0xd3, 0x09, 0x4a, 0xb4, 0x0f, 0xbb, 0x3d, 0x1e, 0xcf, 0x8c, 0x37, 0xe0, 0x36,
	0x2e, 0x2e, 0xca, 0x2a, 0xfc, 0xec, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe5, 0x16, 0x45, 0xad,
	0x2d, 0x07, 0x00, 0x00,
}
