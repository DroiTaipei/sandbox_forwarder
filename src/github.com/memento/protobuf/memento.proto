// Use the protocol buffer compiler to generate client and server code.
// $ protoc --go_out=plugins=grpc:. mongo.proto

syntax = "proto3";

package protobuf;

service Memento {
  rpc Set(RequestCache) returns (SetResult) {}
  rpc Get(RequestKey) returns (Result) {}
  rpc Delete(RequestKey) returns (CodeResult) {}
  rpc Query(RequestQuery) returns (AllResult) {}
  rpc Flush(RequestCollection) returns (CodeResult) {}
  rpc Count(RequestCollection) returns (CountResult) {}
  rpc DropCollection(RequestCollection) returns (CodeResult) {}
}

message RequestCache {
  // key limited less than 1024 bytes
  string Key = 1;
  // BSON contains field : 1. Value limited less than 1MB (this may be changed in the future)
  // Use BSON bytes to help golang preserving type
  bytes BSON = 2;
  string DBN = 3;
  string Collection = 4;
  int32  TTLSec = 5;
  map<string, string> Headers = 6;
}

message RequestKey {
  string Key = 1;
  string DBN = 2;
  string Collection = 3;
  map<string, string> Headers = 4;
}

message RequestCollection {
  string DBN = 1;
  string Collection = 2;
  map<string, string> Headers = 3;
}

message RequestQuery {
  string DBN = 1;
  string Collection = 2;
  bytes BSONQuery = 3;
  map<string, string> Headers = 4;
}

message Data {
  bytes BSON = 1;
  int64 CreatedAt = 2;
  int64 ExpiredAt = 3;
  string Key = 4;
}

message Result {
  int32 Code = 1;
  Data Resp = 2;
  string Error = 3;
}

message SetResult {
  int32 Code = 1;
  int64 ExpiredAt = 2;
  string Error = 3;
}

message AllResult{
  int32 Code = 1;
  repeated Data Resp = 2;
  string Error = 3;
}

message CodeResult {
  int32 Code = 1;
  string Error = 2;
}

message CountResult {
  int32 Code = 1;
  int32 Count = 2;
  string Error = 3;
}